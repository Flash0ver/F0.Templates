#if (Roslyn4_0 || Roslyn4_2)
using System.CodeDom.Compiler;
using System.Diagnostics;
using System.Globalization;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Roslyn.Generator
{
	[Generator(LanguageNames.CSharp)]
	internal sealed partial class HelloWorldGenerator : IIncrementalGenerator
	{
		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			context.RegisterPostInitializationOutput(PostInitializationCallback);

			IncrementalValuesProvider<IGrouping<ISymbol, (MethodDeclarationSyntax node, IMethodSymbol symbol)>> provider = context.SyntaxProvider
				.CreateSyntaxProvider(SyntaxProviderPredicate, SyntaxProviderTransform)
				.Where(static method => method is not null)
				.Collect()
				.SelectMany(static (methods, cancellationToken) => methods.GroupBy(static method => method!.Value.symbol.ContainingType, static method => method!.Value, SymbolEqualityComparer.Default))!;

			context.RegisterSourceOutput(provider, SourceOutputAction);
		}

		private static void PostInitializationCallback(IncrementalGeneratorPostInitializationContext context)
		{
			context.AddSource("HelloWorldAttribute.g.cs", SourceText.From(helloWorldAttribute, Encoding.UTF8));
		}

		private static bool SyntaxProviderPredicate(SyntaxNode syntaxNode, CancellationToken cancellationToken)
		{
			return syntaxNode is MethodDeclarationSyntax
				{
					AttributeLists.Count: > 0,
					ParameterList.Parameters.Count: 0,
				} method
				&& method.Modifiers.Any(SyntaxKind.PartialKeyword);
		}

		private static (MethodDeclarationSyntax node, IMethodSymbol symbol)? SyntaxProviderTransform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
		{
			var method = (MethodDeclarationSyntax)context.Node;

			IMethodSymbol? methodSymbol = context.SemanticModel.GetDeclaredSymbol(method, cancellationToken);

			if (methodSymbol is not null
				&& methodSymbol.ReturnType.SpecialType == SpecialType.System_String
				&& HasHelloWorldAttribute(method, context.SemanticModel, cancellationToken))
			{
				return (method, methodSymbol);
			}

			return null;
		}

		private static bool HasHelloWorldAttribute(MethodDeclarationSyntax method, SemanticModel semanticModel, CancellationToken cancellationToken)
		{
			const string helloWorldAttributeName = "Roslyn.Generated.HelloWorldAttribute";

			foreach (AttributeListSyntax attributeList in method.AttributeLists)
			{
				foreach (AttributeSyntax attribute in attributeList.Attributes)
				{
					if (semanticModel.GetSymbolInfo(attribute, cancellationToken).Symbol is IMethodSymbol attributeSymbol)
					{
						string fullName = attributeSymbol.ContainingType.ToDisplayString();

						if (fullName.Equals(helloWorldAttributeName, StringComparison.Ordinal))
						{
							return true;
						}
					}
				}
			}

			return false;
		}

		private static void SourceOutputAction(SourceProductionContext context, IGrouping<ISymbol, (MethodDeclarationSyntax node, IMethodSymbol symbol)> candidates)
		{
			Debug.Assert(candidates.Any());

			(MethodDeclarationSyntax node, IMethodSymbol symbol) candidate = candidates.First();
			var typeDeclaration = (TypeDeclarationSyntax)candidate.node.Parent!;
			INamedTypeSymbol typeSymbol = candidate.symbol.ContainingType;

			StringBuilder builder = new();
			using StringWriter writer = new(builder, CultureInfo.InvariantCulture);
			using IndentedTextWriter source = new(writer, "\t");

			source.WriteLine("// <auto-generated/>");
			source.WriteLine("#nullable enable");
			source.WriteLine();

			if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
			{
				source.WriteLine($"namespace {typeSymbol.ContainingNamespace}");
				source.WriteLine("{");
				source.Indent++;
			}

			source.WriteLine($"partial {typeDeclaration.Keyword} {typeDeclaration.Identifier.ValueText}");
			source.WriteLine("{");
			source.Indent++;

			foreach ((MethodDeclarationSyntax node, IMethodSymbol symbol) method in candidates)
			{
				source.WriteLine($@"{method.node.Modifiers} string {method.node.Identifier.ValueText}() => ""Hello, World!"";");
			}

			source.Indent--;
			source.WriteLine("}");

			if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
			{
				source.Indent--;
				source.WriteLine("}");
			}

			Debug.Assert(source.Indent == 0);

			string hintName = typeSymbol.ContainingNamespace.IsGlobalNamespace
				? $"{typeDeclaration.Identifier.ValueText}.HelloWorld.g.cs"
				: $"{typeSymbol.ContainingNamespace}.{typeDeclaration.Identifier.ValueText}.HelloWorld.g.cs";
			context.AddSource(hintName, writer.ToString());
		}
	}
}
#endif
