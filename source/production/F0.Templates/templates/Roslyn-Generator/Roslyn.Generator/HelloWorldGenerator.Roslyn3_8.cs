#if (Roslyn3_8 || Roslyn3_9)
using System.CodeDom.Compiler;
using System.Diagnostics;
using System.Globalization;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Roslyn.Generator
{
#if (Roslyn3_8)
	[Generator]
#else
	[Generator(LanguageNames.CSharp)]
#endif
	internal sealed partial class HelloWorldGenerator : ISourceGenerator
	{
		public void Initialize(GeneratorInitializationContext context)
		{
#if (!Roslyn3_8)
			context.RegisterForPostInitialization(PostInitializationCallback);
#endif
			context.RegisterForSyntaxNotifications(HelloWorldReceiver.Create);
		}
#if (!Roslyn3_8)

		private static void PostInitializationCallback(GeneratorPostInitializationContext context)
		{
			context.AddSource("HelloWorldAttribute.g.cs", SourceText.From(helloWorldAttribute, Encoding.UTF8));
		}
#endif

		public void Execute(GeneratorExecutionContext context)
		{
#if (Roslyn3_8)
			context.AddSource("HelloWorldAttribute.g.cs", SourceText.From(helloWorldAttribute, Encoding.UTF8));

#endif
#if (Roslyn3_8)
			if (context.SyntaxReceiver is not HelloWorldReceiver receiver || receiver.CandidateMethods is null)
#else
			if (context.SyntaxContextReceiver is not HelloWorldReceiver receiver || receiver.CandidateMethods is null)
#endif
			{
				return;
			}

			Debug.Assert(receiver.CandidateMethods.Count > 0);

#if (Roslyn3_8)
			foreach ((string typeName, string source) in GenerateSourceCode(receiver.CandidateMethods, context.Compilation, context.CancellationToken))
#else
			foreach ((string typeName, string source) in GenerateSourceCode(receiver.CandidateMethods))
#endif
			{
				context.AddSource($"{typeName}.HelloWorld.g.cs", source);
			}
		}

#if (Roslyn3_8)
		private static IEnumerable<(string typeName, string source)> GenerateSourceCode(IReadOnlyList<MethodDeclarationSyntax> candidateMethods, Compilation compilation, CancellationToken cancellationToken)
#else
		private static IEnumerable<(string typeName, string source)> GenerateSourceCode(IReadOnlyList<(MethodDeclarationSyntax node, IMethodSymbol symbol)> candidateMethods)
#endif
		{
			StringBuilder builder = new();
			using StringWriter writer = new(builder, CultureInfo.InvariantCulture);
			using IndentedTextWriter source = new(writer, "\t");

#if (Roslyn3_8)
			foreach (IGrouping<ISymbol, (MethodDeclarationSyntax node, IMethodSymbol symbol)> candidates in GroupByContainingType(candidateMethods, compilation, cancellationToken))
#else
			foreach (IGrouping<ISymbol, (MethodDeclarationSyntax node, IMethodSymbol symbol)> candidates in GroupByContainingType(candidateMethods))
#endif
			{
				Debug.Assert(candidates.Any());

				(MethodDeclarationSyntax node, IMethodSymbol symbol) candidate = candidates.First();
				var typeDeclaration = (TypeDeclarationSyntax)candidate.node.Parent!;
				INamedTypeSymbol typeSymbol = candidate.symbol.ContainingType;

				source.WriteLine("// <auto-generated/>");
				source.WriteLine("#nullable enable");
				source.WriteLine();

				if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
				{
					source.WriteLine($"namespace {typeSymbol.ContainingNamespace}");
					source.WriteLine("{");
					source.Indent++;
				}

				source.WriteLine($"partial {typeDeclaration.Keyword} {typeDeclaration.Identifier.ValueText}");
				source.WriteLine("{");
				source.Indent++;

#if (Roslyn3_8)
				bool hasGenerated = false;
#endif
				foreach ((MethodDeclarationSyntax node, IMethodSymbol symbol) method in candidates)
				{
#if (Roslyn3_8)
					if (method.symbol.ReturnType.SpecialType != SpecialType.System_String
						|| !HasHelloWorldAttribute(method.node))
					{
						continue;
					}

#endif
					source.WriteLine($@"{method.node.Modifiers} string {method.node.Identifier.ValueText}() => ""Hello, World!"";");
#if (Roslyn3_8)
					hasGenerated = true;
#endif
				}

				source.Indent--;
				source.WriteLine("}");

				if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
				{
					source.Indent--;
					source.WriteLine("}");
				}

				Debug.Assert(source.Indent == 0);

#if (Roslyn3_8)
				if (hasGenerated)
				{
					string typeName = typeSymbol.ContainingNamespace.IsGlobalNamespace
						? typeDeclaration.Identifier.ValueText
						: $"{typeSymbol.ContainingNamespace}.{typeDeclaration.Identifier.ValueText}";
					yield return (typeName, writer.ToString());
				}
#else
				string typeName = typeSymbol.ContainingNamespace.IsGlobalNamespace
					? typeDeclaration.Identifier.ValueText
					: $"{typeSymbol.ContainingNamespace}.{typeDeclaration.Identifier.ValueText}";
				yield return (typeName, writer.ToString());
#endif

				_ = builder.Clear();
			}
		}

#if (Roslyn3_8)
		private static IEnumerable<IGrouping<ISymbol, (MethodDeclarationSyntax node, IMethodSymbol symbol)>> GroupByContainingType(IReadOnlyList<MethodDeclarationSyntax> methods, Compilation compilation, CancellationToken cancellationToken)
		{
			return CombineWithMethodSymbol(methods, compilation, cancellationToken)
				.GroupBy(static method => method.symbol.ContainingType, SymbolEqualityComparer.Default)
				.Where(static grouping => grouping.Key is not null)!;
		}

		private static IEnumerable<(MethodDeclarationSyntax node, IMethodSymbol symbol)> CombineWithMethodSymbol(IReadOnlyList<MethodDeclarationSyntax> methods, Compilation compilation, CancellationToken cancellationToken)
		{
			foreach (MethodDeclarationSyntax method in methods)
			{
				SemanticModel semanticModel = compilation.GetSemanticModel(method.SyntaxTree);

				IMethodSymbol? methodSymbol = semanticModel.GetDeclaredSymbol(method, cancellationToken);

				if (methodSymbol is not null)
				{
					yield return (method, methodSymbol);
				}
			}
		}
#else
		private static IEnumerable<IGrouping<ISymbol, (MethodDeclarationSyntax node, IMethodSymbol symbol)>> GroupByContainingType(IReadOnlyList<(MethodDeclarationSyntax node, IMethodSymbol symbol)> methods)
		{
			return methods.GroupBy(static method => method.symbol.ContainingType, SymbolEqualityComparer.Default)
				.Where(static grouping => grouping.Key is not null)!;
		}
#endif
	}
}
#endif
