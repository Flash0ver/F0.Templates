#if (Roslyn3_8 || Roslyn3_9)
using System.CodeDom.Compiler;
using System.Diagnostics;
using System.Globalization;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Roslyn.Generator
{
#if (Roslyn3_8)
	[Generator]
#else
	[Generator(LanguageNames.CSharp)]
#endif
	internal sealed partial class HelloWorldGenerator : ISourceGenerator
	{
		public void Initialize(GeneratorInitializationContext context)
		{
#if (!Roslyn3_8)
			context.RegisterForPostInitialization(PostInitializationCallback);
#endif
			context.RegisterForSyntaxNotifications(HelloWorldReceiver.Create);
		}
#if (!Roslyn3_8)

		private static void PostInitializationCallback(GeneratorPostInitializationContext context)
		{
			context.AddSource("HelloWorldAttribute.g.cs", SourceText.From(helloWorldAttribute, Encoding.UTF8));
		}
#endif

		public void Execute(GeneratorExecutionContext context)
		{
#if (Roslyn3_8)
			context.AddSource("HelloWorldAttribute.g.cs", SourceText.From(helloWorldAttribute, Encoding.UTF8));

#endif
#if (Roslyn3_8)
			if (context.SyntaxReceiver is not HelloWorldReceiver receiver || receiver.CandidateMethods is null)
#else
			if (context.SyntaxContextReceiver is not HelloWorldReceiver receiver || receiver.CandidateMethods is null)
#endif
			{
				return;
			}

			Debug.Assert(receiver.CandidateMethods.Count > 0);

			foreach ((string typeName, string source) in GenerateSourceCode(receiver.CandidateMethods, context.Compilation, context.CancellationToken))
			{
				context.AddSource($"{typeName}.HelloWorld.g.cs", source);
			}
		}

		private static IEnumerable<(string typeName, string source)> GenerateSourceCode(IReadOnlyList<MethodDeclarationSyntax> candidateMethods, Compilation compilation, CancellationToken cancellationToken)
		{
			StringBuilder builder = new();
			using StringWriter writer = new(builder, CultureInfo.InvariantCulture);
			using IndentedTextWriter source = new(writer, "\t");

			foreach (IGrouping<TypeDeclarationSyntax, MethodDeclarationSyntax> candidateMethod in GroupByContainingType(candidateMethods))
			{
				SemanticModel semanticModel = compilation.GetSemanticModel(candidateMethod.Key.SyntaxTree);

				INamedTypeSymbol? typeSymbol = semanticModel.GetDeclaredSymbol(candidateMethod.Key, cancellationToken);

				if (typeSymbol is null)
				{
					continue;
				}

				source.WriteLine("// <auto-generated/>");
				source.WriteLine("#nullable enable");
				source.WriteLine();

				if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
				{
					source.WriteLine($"namespace {typeSymbol.ContainingNamespace}");
					source.WriteLine("{");
					source.Indent++;
				}

				source.WriteLine($"partial {candidateMethod.Key.Keyword} {candidateMethod.Key.Identifier.ValueText}");
				source.WriteLine("{");
				source.Indent++;

#if (Roslyn3_8)
				bool hasGenerated = false;
#endif
				foreach (MethodDeclarationSyntax methodDeclaration in candidateMethod)
				{
#if (Roslyn3_8)
					if (!DoesReturnString(methodDeclaration, semanticModel, cancellationToken)
						|| !HasHelloWorldAttribute(methodDeclaration))
					{
						continue;
					}

#endif
					source.WriteLine($@"{methodDeclaration.Modifiers} string {methodDeclaration.Identifier.ValueText}() => ""Hello, World!"";");
#if (Roslyn3_8)
					hasGenerated = true;
#endif
				}

				source.Indent--;
				source.WriteLine("}");

				if (!typeSymbol.ContainingNamespace.IsGlobalNamespace)
				{
					source.Indent--;
					source.WriteLine("}");
				}

				Debug.Assert(source.Indent == 0);

#if (Roslyn3_8)
				if (hasGenerated)
				{
					yield return (candidateMethod.Key.Identifier.ValueText, writer.ToString());
				}
#else
				yield return (candidateMethod.Key.Identifier.ValueText, writer.ToString());
#endif

				_ = builder.Clear();
			}
		}

		private static IEnumerable<IGrouping<TypeDeclarationSyntax, MethodDeclarationSyntax>> GroupByContainingType(IReadOnlyList<MethodDeclarationSyntax> methods)
		{
			return methods.GroupBy(static method => method.Parent as TypeDeclarationSyntax, TypeIdentifierEqualityComparer.Instance)
				.Where(static grouping => grouping.Key is not null)!;
		}
	}
}
#endif
